# **高性能代理与隧道平台 - 系统架构设计文档**

版本: 1.0  
日期: 2025年1月18日  
作者: ccnochch  
状态: 草案 (Draft)

## **1. 架构设计概述**

### **1.1 设计原则**

基于PRD需求和技术选型，系统架构遵循以下设计原则：

- **微服务架构**: 服务间松耦合，独立部署和扩展
- **高可用性**: 单点故障不影响整体服务
- **高性能**: 满足1000+ QPS和<200ms响应时间要求
- **安全性**: 多层防护，数据加密，访问控制
- **可观测性**: 全链路监控，日志集中管理
- **可扩展性**: 支持水平扩展，便于未来功能扩展

### **1.2 整体架构概览**

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   用户层        │    │   接入层         │    │   应用层        │
│   Web浏览器     │    │   Nginx负载均衡  │    │   网关服务      │
│   API客户端     │◄──►│   SSL终端        │◄──►│   管理后台API   │
│   第三方应用    │    │                  │    │   代理池服务    │
└─────────────────┘    └──────────────────┘    │   免费代理爬虫  │
                                               └─────────────────┘
                                                        │
┌─────────────────┐    ┌──────────────────┐           ▼
│   外部服务      │    │   数据层         │    ┌─────────────────┐
│   商业代理API   │◄──►│   Redis集群      │◄──►│   监控层        │
│   支付网关      │    │   MySQL主从      │    │   Prometheus    │
│   免费代理网站  │    │   日志存储       │    │   Grafana       │
└─────────────────┘    └──────────────────┘    │   Loki          │
                                               └─────────────────┘
```

## **2. 核心服务架构设计**

### **2.1 网关服务 (Proxy Gateway)**

#### **2.1.1 服务职责**
- 接收客户端代理请求
- 用户认证与授权
- 代理IP调度与分配
- HTTP/HTTPS隧道建立
- 请求转发与响应处理
- 流量统计与监控

#### **2.1.2 关键组件设计**

**认证中间件:**
```go
type AuthMiddleware struct {
    redis     *redis.Client
    jwtSecret []byte
}

func (m *AuthMiddleware) Authenticate(c *gin.Context) {
    // 1. 提取API Key
    apiKey := extractAPIKey(c)
    
    // 2. Redis验证API Key有效性
    userInfo, err := m.redis.HGetAll(fmt.Sprintf("api_key:%s", apiKey)).Result()
    if err != nil || len(userInfo) == 0 {
        c.JSON(401, gin.H{"error": "Invalid API key"})
        c.Abort()
        return
    }
    
    // 3. 检查用户状态和套餐限制
    if !m.checkUserStatus(userInfo) {
        c.JSON(403, gin.H{"error": "Account suspended or quota exceeded"})
        c.Abort()
        return
    }
    
    // 4. 设置用户上下文
    c.Set("user_id", userInfo["user_id"])
    c.Set("subscription_plan", userInfo["plan"])
    c.Next()
}
```

**代理调度器:**
```go
type ProxyScheduler struct {
    localCache  *cache.LRUCache
    redis       *redis.Client
    poolService *ProxyPoolService
}

func (s *ProxyScheduler) GetProxyIP(req ProxyRequest) (*ProxyIP, error) {
    // 1. 尝试本地缓存
    if proxy := s.localCache.Get(req.CacheKey()); proxy != nil {
        return proxy.(*ProxyIP), nil
    }
    
    // 2. 从Redis获取最优代理
    proxyIP, err := s.getFromRedis(req)
    if err != nil {
        // 3. 缓存未命中，调用代理池服务
        proxyIP, err = s.poolService.AllocateProxy(req)
        if err != nil {
            return nil, err
        }
    }
    
    // 4. 更新本地缓存
    s.localCache.Set(req.CacheKey(), proxyIP, 5*time.Minute)
    
    return proxyIP, nil
}
```

### **2.2 代理池服务 (Proxy Pool Service)**

#### **2.2.1 核心算法设计**

**场景感知质量评分算法:**
```go
type QualityScorer struct {
    redis *redis.Client
}

type QualityMetrics struct {
    SuccessRate    float64 // 总体成功率
    AvgLatency     int64   // 平均延迟
    AnonymityLevel int     // 匿名等级 1-3
    DomainScores   map[string]float64 // 按域名的成功率
    GeoLocation    string  // 地理位置
    LastUpdate     time.Time
}

func (qs *QualityScorer) CalculateScore(proxyIP string, targetDomain string) float64 {
    metrics := qs.getMetrics(proxyIP)
    
    // 基础分数 (0-100)
    baseScore := 0.0
    
    // 成功率权重 40%
    baseScore += metrics.SuccessRate * 40
    
    // 延迟权重 30% (延迟越低分数越高)
    latencyScore := math.Max(0, 100 - float64(metrics.AvgLatency)/10)
    baseScore += latencyScore * 0.3
    
    // 匿名等级权重 20%
    baseScore += float64(metrics.AnonymityLevel) * 20 / 3
    
    // 场景加权 10%
    if domainScore, exists := metrics.DomainScores[targetDomain]; exists {
        baseScore += domainScore * 10
    }
    
    // 时效性衰减
    timeFactor := qs.calculateTimeFactor(metrics.LastUpdate)
    
    return baseScore * timeFactor
}
```

### **2.3 免费代理爬虫服务**

#### **2.3.1 多站点爬虫设计**

```go
type CrawlerManager struct {
    sites       []CrawlSite
    scheduler   *cron.Cron
    validator   *ProxyValidator
    antiCrawl   *AntiCrawlManager
}

type CrawlSite struct {
    Name     string
    URL      string
    Parser   ParserFunc
    Interval time.Duration
    Priority int
}

func (cm *CrawlerManager) StartCrawling() {
    for _, site := range cm.sites {
        site := site // 避免闭包问题
        cm.scheduler.AddFunc(cm.cronExpr(site.Interval), func() {
            cm.crawlSite(site)
        })
    }
    cm.scheduler.Start()
}
```

## **3. 数据架构设计**

### **3.1 MySQL数据库设计**

#### **3.1.1 用户相关表**
```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    subscription_plan ENUM('free','developer','professional','enterprise') DEFAULT 'developer',
    status ENUM('active','suspended','deleted') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_email (email),
    INDEX idx_status (status)
);

-- API密钥表
CREATE TABLE api_keys (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    api_key VARCHAR(64) UNIQUE NOT NULL,
    name VARCHAR(100) DEFAULT 'Default Key',
    is_active BOOLEAN DEFAULT TRUE,
    last_used_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_api_key (api_key),
    INDEX idx_user_id (user_id)
);

-- 订阅表
CREATE TABLE subscriptions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    plan_type ENUM('developer','professional','enterprise') NOT NULL,
    status ENUM('active','expired','cancelled') DEFAULT 'active',
    traffic_quota BIGINT NOT NULL, -- 流量配额(字节)
    traffic_used BIGINT DEFAULT 0, -- 已使用流量
    requests_quota INT NOT NULL,   -- 请求配额
    requests_used INT DEFAULT 0,   -- 已使用请求数
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_status (user_id, status),
    INDEX idx_expires (expires_at)
);
```

### **3.2 Redis数据结构设计**

#### **3.2.1 代理池数据结构**
```redis
# 按类型和地理位置分组的可用代理池
SET proxies:datacenter:US     # 美国数据中心代理
SET proxies:residential:UK    # 英国住宅代理
SET proxies:mobile:JP         # 日本移动代理

# 代理IP详细信息
HASH ip:1.2.3.4 {
    "type": "datacenter",
    "country": "US",
    "city": "New York", 
    "port": "8080",
    "username": "user1",
    "password": "pass1",
    "success_rate": "95.5",
    "avg_latency": "120",
    "anonymity_level": "3",
    "last_check": "1705123456",
    "status": "active"
}

# 按质量评分排序的代理池
ZSET quality:datacenter:US    # score为质量评分，member为IP
ZSET quality:residential:UK

# 免费代理池(隔离存储)
SET free_proxies:datacenter:US
HASH free_ip:5.6.7.8 {
    "type": "datacenter",
    "country": "US",
    "source": "free-proxy-list.net",
    "success_rate": "60.0",
    "created_at": "1705123456",
    "expires_at": "1705209856"
}

# 会话保持
STRING session:abc123 "1.2.3.4:8080" EX 300  # 5分钟过期
```

## **4. 接口设计**

### **4.1 网关代理接口**

#### **4.1.1 HTTP代理接口**
```http
# 基础HTTP代理请求
GET http://target-website.com HTTP/1.1
Host: target-website.com
Proxy-Authorization: Bearer pk_your_api_key_here
X-Proxy-Country: US
X-Proxy-Type: datacenter
X-Session-ID: optional_session_id
```

#### **4.1.2 HTTPS隧道接口** 
```http
# CONNECT隧道建立
CONNECT target-website.com:443 HTTP/1.1
Host: target-website.com:443
Proxy-Authorization: Bearer pk_your_api_key_here
X-Proxy-Country: US
X-Proxy-Type: residential
```

### **4.2 管理后台API接口**

#### **4.2.1 统计分析API**
```yaml
# 获取使用统计
GET /api/stats/usage?range=7d
Authorization: Bearer jwt_token

# 响应
{
  "total_requests": 15420,
  "successful_requests": 14688,
  "success_rate": 95.25,
  "total_traffic": "2.5GB",
  "average_latency": 185,
  "domain_breakdown": {
    "amazon.com": {"requests": 5000, "success_rate": 96.2},
    "google.com": {"requests": 3000, "success_rate": 98.1}
  },
  "geo_breakdown": {
    "US": {"requests": 8000, "success_rate": 95.8},
    "UK": {"requests": 4000, "success_rate": 94.2}
  }
}
```

## **5. 安全架构设计**

### **5.1 多层认证机制**
```go
type SecurityManager struct {
    jwtService    *JWTService
    apiKeyService *APIKeyService  
    rateLimiter   *RateLimiter
}

func (sm *SecurityManager) AuthenticateRequest(c *gin.Context) error {
    // 1. API Key认证
    apiKey := extractAPIKey(c)
    if apiKey == "" {
        return errors.New("missing API key")
    }
    
    // 2. 验证API Key有效性
    keyInfo, err := sm.apiKeyService.Validate(apiKey)
    if err != nil {
        return err
    }
    
    // 3. 检查用户状态
    if keyInfo.UserStatus != "active" {
        return errors.New("user account suspended")
    }
    
    // 4. 限流检查
    if !sm.rateLimiter.Allow(keyInfo.UserID) {
        return errors.New("rate limit exceeded")
    }
    
    c.Set("user_context", keyInfo)
    return nil
}
```

## **6. 监控与可观测性架构**

### **6.1 关键监控指标**

```go
// Prometheus指标定义
var (
    // 请求相关指标
    requestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "proxy_requests_total",
            Help: "Total number of proxy requests",
        },
        []string{"user_id", "country", "status"},
    )
    
    requestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "proxy_request_duration_seconds",
            Help: "Proxy request duration",
            Buckets: prometheus.DefBuckets,
        },
        []string{"user_id", "country"},
    )
    
    // 代理池指标
    availableProxies = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "available_proxies_count", 
            Help: "Number of available proxies",
        },
        []string{"type", "country"},
    )
)
```

## **7. 部署架构设计**

### **7.1 Docker Compose完整配置**
```yaml
version: '3.8'

services:
  # 负载均衡和SSL终端
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - gateway-1
      - gateway-2
      - admin-api
    networks:
      - proxy-network

  # 网关服务(多实例)
  gateway-1:
    build: ./services/gateway
    environment:
      - REDIS_URL=redis://redis-master:6379
      - MYSQL_URL=mysql://mysql-master:3306/proxy_platform
      - PROXY_POOL_URL=http://proxy-pool:8080
    depends_on:
      - redis-master
      - mysql-master
      - proxy-pool
    networks:
      - proxy-network

  gateway-2:
    build: ./services/gateway
    environment:
      - REDIS_URL=redis://redis-master:6379
      - MYSQL_URL=mysql://mysql-master:3306/proxy_platform  
      - PROXY_POOL_URL=http://proxy-pool:8080
    depends_on:
      - redis-master
      - mysql-master
      - proxy-pool
    networks:
      - proxy-network

  # 管理后台API
  admin-api:
    build: ./services/admin-api
    ports:
      - "8081:8081"
    environment:
      - MYSQL_URL=mysql://mysql-master:3306/proxy_platform
      - REDIS_URL=redis://redis-master:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - mysql-master
      - redis-master
    networks:
      - proxy-network

  # 代理池核心服务
  proxy-pool:
    build: ./services/proxy-pool
    environment:
      - REDIS_URL=redis://redis-master:6379
      - BRIGHTDATA_API_KEY=${BRIGHTDATA_API_KEY}
    depends_on:
      - redis-master
    networks:
      - proxy-network

  # 免费代理爬虫
  free-proxy-crawler:
    build: ./services/free-proxy-crawler
    environment:
      - REDIS_URL=redis://redis-master:6379
      - CRAWLER_INTERVAL=6h
      - MAX_CONCURRENT=2
    depends_on:
      - redis-master
    networks:
      - proxy-network

  # Redis主从集群
  redis-master:
    image: redis:6.2-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis-master-data:/data
    networks:
      - proxy-network

  # MySQL主从
  mysql-master:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=proxy_platform
      - MYSQL_USER=proxy_user
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    volumes:
      - mysql-master-data:/var/lib/mysql
    networks:
      - proxy-network

  # 监控服务
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    networks:
      - proxy-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - proxy-network

volumes:
  redis-master-data:
  mysql-master-data:
  prometheus-data:
  grafana-data:

networks:
  proxy-network:
    driver: bridge
```

## **8. 总结**

本系统架构设计文档基于PRD需求和技术选型，提供了完整的架构设计方案：

### **8.1 架构特点**
- **微服务架构**: 服务独立，便于开发和部署
- **高性能设计**: 满足1000+ QPS和<200ms延迟要求
- **高可用保障**: 主从架构，故障自动切换
- **安全防护**: 多层安全机制，数据加密保护
- **可观测性**: 全链路监控，实时告警

### **8.2 技术亮点**
- **智能调度算法**: 场景感知的代理质量评分
- **数据隔离设计**: 免费代理与商业代理物理隔离
- **反爬虫策略**: 多种技术手段应对反爬虫
- **缓存优化**: Redis + 本地缓存双层架构
- **监控完善**: Prometheus + Grafana监控体系

该架构设计为MVP阶段提供了坚实的技术基础，同时为后续产品发展预留了充分的扩展空间。 